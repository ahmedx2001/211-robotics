#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Bow,            sensorPotentiometer)
#pragma config(Sensor, dgtl9,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           Tension,       tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           Left1,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           Left2,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           Left3,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           Right1,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Right2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Right3,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           BowLeft,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           BowRight,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          Intake,        tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "Functions.c"



void pre_auton()
{
	bStopTasksBetweenModes = true;

}



task autonomous()
{
		motor[BowLeft] = 127;
	motor[BowRight] = 127;

while (SensorValue(Bow) < 3700){
		wait(100);
	}
	while (SensorValue(Bow) < 1000){
		wait(100);
	}
	motor[BowLeft] = 0;
	motor[BowRight] = 0;
}


task usercontrol()
{
	int cycles = 0;
	int TensionSpeed = 0;
	startTask(LCD);
	while(1==1){
		////// DRIVE BASE STICK //////
		motor[Left1]  = (vexRT[Ch3]+vexRT[Ch4]);
		motor[Left2]  = (vexRT[Ch3]+vexRT[Ch4]);
		motor[Left3]  = (vexRT[Ch3]+vexRT[Ch4]);
		motor[Right1]   = (vexRT[Ch3]-vexRT[Ch4]);
		motor[Right2]   = (vexRT[Ch3]-vexRT[Ch4]);
		motor[Right3]   = (vexRT[Ch3]-vexRT[Ch4]);

		////// Bow //////
		motor[BowLeft]  = (vexRT[Ch2]);
		motor[BowRight]  = (vexRT[Ch2]);

		/////// TENSION ////////
		if(vexRT[Btn5U] == 1){
			cycles++;
			motor[Tension]   = (cycles*0.05);
		}
		else if(vexRT[Btn5D] == 1){
			cycles++;
			motor[Tension]   = -(cycles*0.05);
		}
		else {
			cycles = 0;
			motor[Tension]   = 0;
		}

		/////// INTAKE ////////
		if(vexRT[Btn6U] == 1){
			motor[Intake]   = -127;
		}
		else if(vexRT[Btn6D] == 1){
			while(vexRT[Btn6D] == 1){
				motor[Intake]   = 127;
			}
			motor[Intake]   = 0;
		}

		//////// AUTO TEST ////////
		if(vexRT[Btn7U] == 1){
			// Put auto test code here
		}


	}
}
